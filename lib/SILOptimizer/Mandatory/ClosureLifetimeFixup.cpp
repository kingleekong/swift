//===--- ClosureLifetimeFixup.cpp - Fixup the lifetime of closures --------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "closure-lifetime-fixup"

#include "swift/SIL/DebugUtils.h"
#include "swift/SIL/InstructionUtils.h"
#include "swift/SIL/SILArgument.h"
#include "swift/SIL/SILBuilder.h"
#include "swift/SIL/SILInstruction.h"
#include "swift/SILOptimizer/PassManager/Passes.h"
#include "swift/SILOptimizer/PassManager/Transforms.h"
#include "swift/SILOptimizer/Utils/CFG.h"
#include "swift/SILOptimizer/Utils/Local.h"
#include "swift/SILOptimizer/Utils/SILSSAUpdater.h"
#include "swift/SILOptimizer/Utils/StackNesting.h"

#include "llvm/Support/CommandLine.h"

llvm::cl::opt<bool> DisableConvertEscapeToNoEscapeSwitchEnumPeephole(
    "sil-disable-convert-escape-to-noescape-switch-peephole",
    llvm::cl::init(false),
    llvm::cl::desc(
        "Disable the convert_escape_to_noescape switch enum peephole. "),
    llvm::cl::Hidden);

using namespace swift;

static SILBasicBlock *getOptionalDiamondSuccessor(SwitchEnumInst *sei) {
  auto numSuccs = sei->getNumSuccessors();
  if (numSuccs != 2)
    return nullptr;
  auto *succSome = sei->getCase(0).second;
  auto *succNone = sei->getCase(1).second;
  if (succSome->args_size() != 1)
    std::swap(succSome, succNone);

  if (succSome->args_size() != 1 || succNone->args_size() != 0)
    return nullptr;

  auto *succ = succSome->getSingleSuccessorBlock();
  if (!succ)
    return nullptr;

  if (succNone == succ)
    return succ;

  succNone = succNone->getSingleSuccessorBlock();
  if (succNone == succ)
    return succ;

  if (succNone == nullptr)
    return nullptr;

  succNone = succNone->getSingleSuccessorBlock();
  if (succNone == succ)
    return succ;

  return nullptr;
}

/// Find a safe insertion point for closure destruction. We might create a
/// closure that captures self in deinit of self. In this situation it is not
/// safe to destroy the closure after we called super deinit. We have to place
/// the closure destruction before that call.
///
///  %deinit = objc_super_method %0 : $C, #A.deinit!deallocator.foreign
///  %super = upcast %0 : $C to $A
///  apply %deinit(%super) : $@convention(objc_method) (A) -> ()
///  end_lifetime %super : $A
static SILInstruction *getDeinitSafeClosureDestructionPoint(TermInst *Term) {
  for (auto It = Term->getParent()->rbegin(), E = Term->getParent()->rend();
       It != E; ++It) {
    if (auto *EndLifetime = dyn_cast<EndLifetimeInst>(&*It)) {
      auto *SuperInstance = EndLifetime->getOperand()->getDefiningInstruction();
      assert(SuperInstance && "Expected an instruction");
      return SuperInstance;
    }
  }
  return Term;
}

static void findReachableExitBlocks(SILInstruction *i,
                                    SmallVectorImpl<SILBasicBlock *> &result) {
  SmallVector<SILBasicBlock *, 32> worklist;
  SmallPtrSet<SILBasicBlock *, 8> visitedBlocks;

  visitedBlocks.insert(i->getParent());
  worklist.push_back(i->getParent());

  while (!worklist.empty()) {
    auto *bb = worklist.pop_back_val();
    if (bb->getTerminator()->isFunctionExiting()) {
      result.push_back(bb);
      continue;
    }
    copy_if(bb->getSuccessorBlocks(), std::back_inserter(worklist),
            [&](SILBasicBlock *bb) { return visitedBlocks.insert(bb).second; });
  }
}

/// Extend the lifetime of the convert_escape_to_noescape's operand to the end
/// of the function.
///
/// NOTE: Since we are lifetime extending a copy that we have introduced, we do
/// not need to consider destroy_value emitted by SILGen unlike
/// copy_block_without_escaping which consumes its sentinel parameter. Unlike
/// that case where we have to consider that destroy_value, we have a simpler
/// time here.
static void extendLifetimeToEndOfFunction(SILFunction &Fn,
                                          ConvertEscapeToNoEscapeInst *Cvt) {
  auto EscapingClosure = Cvt->getOperand();
  auto EscapingClosureTy = EscapingClosure->getType();
  auto OptionalEscapingClosureTy = SILType::getOptionalType(EscapingClosureTy);
  auto loc = RegularLocation::getAutoGeneratedLocation();

  SILBuilderWithScope B(Cvt);
  auto NewCvt = B.createConvertEscapeToNoEscape(
      Cvt->getLoc(), Cvt->getOperand(), Cvt->getType(), true);
  Cvt->replaceAllUsesWith(NewCvt);
  Cvt->eraseFromParent();
  Cvt = NewCvt;

  // If our Cvt is in the initial block, we do not need to use the SSA updater
  // since we know Cvt can not be in a loop and must dominate all exits
  // (*). Just insert a copy of the escaping closure at the Cvt and destroys at
  // the exit blocks of the function.
  //
  // (*) In fact we can't use the SILSSAUpdater::GetValueInMiddleOfBlock.
  if (Cvt->getParent() == Cvt->getFunction()->getEntryBlock()) {
    SILBuilderWithScope B(Cvt);
    CopyValueInst *InnerCVI = B.createCopyValue(loc, EscapingClosure);
    SmallVector<SILBasicBlock *, 4> ExitingBlocks;
    Fn.findExitingBlocks(ExitingBlocks);

    for (auto *Exit : ExitingBlocks) {
      auto *Term = Exit->getTerminator();
      auto *SafeClosureDestructionPt =
          getDeinitSafeClosureDestructionPoint(Term);
      SILBuilderWithScope B(SafeClosureDestructionPt);
      B.createDestroyValue(loc, InnerCVI);
    }
    return;
  }

  // Ok. At this point we know that Cvt is not in the entry block... so we can
  // use SILSSAUpdater::GetValueInMiddleOfBlock() to extend the object's
  // lifetime respecting loops.
  SILSSAUpdater Updater(Cvt->getModule());
  Updater.Initialize(OptionalEscapingClosureTy);

  // Create an Optional<() -> ()>.none in the entry block of the function and
  // add it as an available value to the SSAUpdater.
  //
  // Since we know that Cvt is not in the entry block and this must be, we know
  // that it is safe to use the SSAUpdater's getValueInMiddleOfBlock with this
  // value.
  Updater.AddAvailableValue(Fn.getEntryBlock(), [&]() -> SILValue {
    SILBuilderWithScope B(Fn.getEntryBlock()->begin());
    return B.createOptionalNone(loc, OptionalEscapingClosureTy);
  }());

  // Create a copy of the convert_escape_to_no_escape and add it as an available
  // value to the SSA updater.
  //
  // NOTE: The SSAUpdater does not support providing multiple values in the same
  // block without extra work. So the fact that Cvt is not in the entry block
  // means that we don't have to worry about overwriting the .none value.
  auto *CVI = [&]() -> CopyValueInst * {
    SILBuilderWithScope B(Cvt);
    CopyValueInst *InnerCVI = B.createCopyValue(loc, EscapingClosure);
    Updater.AddAvailableValue(
        Cvt->getParent(),
        B.createOptionalSome(loc, InnerCVI, OptionalEscapingClosureTy));
    return InnerCVI;
  }();

  // Then we use the SSA updater to insert a destroy_value before the cvt and at
  // the reachable exit blocks.
  SmallVector<SILBasicBlock *, 4> ExitingBlocks;
  findReachableExitBlocks(Cvt, ExitingBlocks);

  {
    // Before the copy value, insert an extra destroy_value to handle
    // loops. Since we used our enum value this is safe.
    SILBuilderWithScope B(CVI);
    B.createDestroyValue(loc,
                         Updater.GetValueInMiddleOfBlock(CVI->getParent()));
  }

  for (auto *Exit : ExitingBlocks) {
    auto *Term = Exit->getTerminator();
    auto *SafeClosureDestructionPt = getDeinitSafeClosureDestructionPoint(Term);
    SILBuilderWithScope B(SafeClosureDestructionPt);
    B.createDestroyValue(loc, Updater.GetValueAtEndOfBlock(Exit));
  }
}

static SILInstruction *lookThroughRebastractionUsers(
    SILInstruction *Inst,
    llvm::DenseMap<SILInstruction *, SILInstruction *> &Memoized) {

  if (Inst == nullptr)
    return nullptr;

  // Try a cached lookup.
  auto Res = Memoized.find(Inst);
  if (Res != Memoized.end())
    return Res->second;

  // Cache recursive results.
  auto memoizeResult = [&] (SILInstruction *from, SILInstruction *toResult) {
    Memoized[from] = toResult;
    return toResult;
  };

  // If we have a convert_function, just look at its user.
  if (auto *Cvt = dyn_cast<ConvertFunctionInst>(Inst))
    return memoizeResult(Inst, lookThroughRebastractionUsers(
                                   getSingleNonDebugUser(Cvt), Memoized));
  if (auto *Cvt = dyn_cast<ConvertEscapeToNoEscapeInst>(Inst))
    return memoizeResult(Inst, lookThroughRebastractionUsers(
                                   getSingleNonDebugUser(Cvt), Memoized));

  // If we have a partial_apply user look at its single (non release) user.
  auto *PA = dyn_cast<PartialApplyInst>(Inst);
  if (!PA) return Inst;

  SILInstruction *SingleNonDebugNonRefCountUser = nullptr;
  for (auto *Usr : getNonDebugUses(PA)) {
    auto *I = Usr->getUser();
    if (onlyAffectsRefCount(I))
      continue;
    if (SingleNonDebugNonRefCountUser) {
      SingleNonDebugNonRefCountUser = nullptr;
      break;
    }
    SingleNonDebugNonRefCountUser = I;
  }

  return memoizeResult(Inst, lookThroughRebastractionUsers(
                                 SingleNonDebugNonRefCountUser, Memoized));
}

/// Insert a mark_dependence for any non-trivial argument of a partial_apply.
static SILValue insertMarkDependenceForCapturedArguments(PartialApplyInst *PAI,
                                                         SILBuilder &B) {
  SILValue curr(PAI);
  // Mark dependence on all non-trivial arguments.
  for (auto &arg : PAI->getArgumentOperands()) {
    if (arg.get()->getType().isTrivial(PAI->getModule()))
      continue;
    curr = B.createMarkDependence(PAI->getLoc(), curr, arg.get());
  }

  return curr;
}

/// Rewrite a partial_apply convert_escape_to_noescape sequence with a single
/// apply/try_apply user to a partial_apply [stack] terminated with a
/// dealloc_stack placed after the apply.
///
///   %p = partial_apply %f(%a, %b)
///   %ne = convert_escape_to_noescape %p
///   apply %f2(%p)
///   destroy_value %p
///
///    =>
///
///   %p = partial_apply [stack] %f(%a, %b)
///   %md = mark_dependence %p on %a
///   %md2 = mark_dependence %md on %b
///   apply %f2(%md2)
///   dealloc_stack %p
///   destroy_value %a
///   destroy_value %b
///
/// Note: If the rewrite succeeded we have inserted a dealloc_stack. This
/// dealloc_stack still needs to be balanced with other dealloc_stacks i.e the
/// caller needs to use the StackNesting utility to update the dealloc_stack
/// nesting.
static bool tryRewriteToPartialApplyStack(
    SILLocation &loc, PartialApplyInst *origPA,
    ConvertEscapeToNoEscapeInst *cvt, SILInstruction *singleApplyUser,
    SILBasicBlock::iterator &advanceIfDelete,
    llvm::DenseMap<SILInstruction *, SILInstruction *> &Memoized) {

  auto *convertOrPartialApply = cast<SingleValueInstruction>(origPA);
  if (cvt->getOperand() != origPA)
    convertOrPartialApply = cast<ConvertFunctionInst>(cvt->getOperand());

  // Whenever we delete an instruction advance the iterator and remove the
  // instruction from the memoized map.
  auto saveDeleteInst = [&](SILInstruction *I) {
    if (&*advanceIfDelete == I)
      advanceIfDelete++;
    Memoized.erase(I);
    I->eraseFromParent();
  };

  // Look for a single non ref count user of the partial_apply.
  SmallVector<SILInstruction *, 8> refCountInsts;
  SILInstruction *singleNonDebugNonRefCountUser = nullptr;
  for (auto *Usr : getNonDebugUses(convertOrPartialApply)) {
    auto *I = Usr->getUser();
    if (onlyAffectsRefCount(I)) {
      refCountInsts.push_back(I);
      continue;
    }
    if (singleNonDebugNonRefCountUser)
      return false;
    singleNonDebugNonRefCountUser = I;
  }

  SILBuilderWithScope B(cvt);

  // The convert_escape_to_noescape is the only user of the partial_apply.
  // Convert to a partial_apply [stack].
  SmallVector<SILValue, 8> args;
  for (auto &arg : origPA->getArgumentOperands())
    args.push_back(arg.get());
  auto newPA = B.createPartialApply(
      origPA->getLoc(), origPA->getCallee(), origPA->getSubstitutionMap(), args,
      origPA->getType().getAs<SILFunctionType>()->getCalleeConvention(),
      PartialApplyInst::OnStackKind::OnStack);

  // Insert mark_dependence for any non-trivial operand to the partial_apply.
  auto closure = insertMarkDependenceForCapturedArguments(newPA, B);

  // Optionally, replace the convert_function instruction.
  if (auto *convert = dyn_cast<ConvertFunctionInst>(convertOrPartialApply)) {
    auto origTy = convert->getType().castTo<SILFunctionType>();
    auto origWithNoEscape = SILType::getPrimitiveObjectType(
        origTy->getWithExtInfo(origTy->getExtInfo().withNoEscape()));
    closure = B.createConvertFunction(convert->getLoc(), closure, origWithNoEscape, false);
    convert->replaceAllUsesWith(closure);
  }

  // Replace the convert_escape_to_noescape uses with the new
  // partial_apply [stack].
  cvt->replaceAllUsesWith(closure);
  saveDeleteInst(cvt);

  // Delete the ref count operations on the original partial_apply.
  for (auto *refInst : refCountInsts)
    saveDeleteInst(refInst);
  convertOrPartialApply->replaceAllUsesWith(newPA);
  if (convertOrPartialApply != origPA)
    saveDeleteInst(convertOrPartialApply);
  saveDeleteInst(origPA);

  // Insert destroys of arguments after the apply and the dealloc_stack.
  if (auto *Apply = dyn_cast<ApplyInst>(singleApplyUser)) {
    auto InsertPt = std::next(SILBasicBlock::iterator(Apply));
    // Don't insert dealloc_stacks at unreachable.
    if (isa<UnreachableInst>(*InsertPt))
      return true;
    SILBuilderWithScope B3(InsertPt);
    B3.createDeallocStack(loc, newPA);
    insertDestroyOfCapturedArguments(newPA, B3);
  } else if (auto *Try = dyn_cast<TryApplyInst>(singleApplyUser)) {
    for (auto *SuccBB : Try->getSuccessorBlocks()) {
      SILBuilderWithScope B3(SuccBB->begin());
      B3.createDeallocStack(loc, newPA);
      insertDestroyOfCapturedArguments(newPA, B3);
    }
  } else {
    llvm_unreachable("Unknown FullApplySite instruction kind");
  }
  return true;
}

static SILValue skipConvert(SILValue v) {
  auto cvt = dyn_cast<ConvertFunctionInst>(v);
  if (!cvt)
    return v;
  auto *pa = dyn_cast<PartialApplyInst>(cvt->getOperand());
  if (!pa || !pa->hasOneUse())
    return v;
  return pa;
}

static bool tryExtendLifetimeToLastUse(
    ConvertEscapeToNoEscapeInst *Cvt,
    llvm::DenseMap<SILInstruction *, SILInstruction *> &Memoized,
    SILBasicBlock::iterator &AdvanceIfDelete) {
  // If there is a single user that is an apply this is simple: extend the
  // lifetime of the operand until after the apply.
  auto SingleUser = lookThroughRebastractionUsers(Cvt, Memoized);
  if (!SingleUser)
    return false;

  // Handle an apply.
  if (auto SingleApplyUser = FullApplySite::isa(SingleUser)) {
    // FIXME: Don't know how-to handle begin_apply/end_apply yet.
    if (isa<BeginApplyInst>(SingleApplyUser.getInstruction())) {
      return false;
    }

    auto loc = RegularLocation::getAutoGeneratedLocation();
    auto origPA = dyn_cast<PartialApplyInst>(skipConvert(Cvt->getOperand()));
    if (origPA && tryRewriteToPartialApplyStack(
                      loc, origPA, Cvt, SingleApplyUser.getInstruction(),
                      AdvanceIfDelete,
                      Memoized))
      return true;

    // Insert a copy at the convert_escape_to_noescape [not_guaranteed] and
    // change the instruction to the guaranteed form.
    auto EscapingClosure = Cvt->getOperand();
    {
      SILBuilderWithScope B(Cvt);
      auto NewCvt = B.createConvertEscapeToNoEscape(
          Cvt->getLoc(), Cvt->getOperand(), Cvt->getType(), true);
      Cvt->replaceAllUsesWith(NewCvt);
      Cvt->eraseFromParent();
      Cvt = NewCvt;
    }

    SILBuilderWithScope B2(Cvt);
    auto ClosureCopy = B2.createCopyValue(loc, EscapingClosure);

    // Insert a destroy after the apply.
    if (auto *Apply = dyn_cast<ApplyInst>(SingleApplyUser.getInstruction())) {
      auto InsertPt = std::next(SILBasicBlock::iterator(Apply));
      SILBuilderWithScope B3(InsertPt);
      B3.createDestroyValue(loc, ClosureCopy);

    } else if (auto *Try =
                   dyn_cast<TryApplyInst>(SingleApplyUser.getInstruction())) {
      for (auto *SuccBB : Try->getSuccessorBlocks()) {
        SILBuilderWithScope B3(SuccBB->begin());
        B3.createDestroyValue(loc, ClosureCopy);
      }
    } else {
      llvm_unreachable("Unknown FullApplySite instruction kind");
    }
    return true;
  }
  return false;
}

/// Ensure the lifetime of the closure accross an
///
///   optional<@escaping () -> ()> to
///   optional<@noescape @convention(block) () -> ()>
///
///   conversion and its use.
///
///   The pattern this is looking for
///                            switch_enum %closure
///                           /           \
///     convert_escape_to_noescape          nil
///                             switch_enum
///                           /           \
///                convertToBlock          nil
///                           \            /
///                     (%convertOptionalBlock :)
///   We will insert a copy_value of the original %closure before the two
///   diamonds. And a destroy of %closure at the last destroy of
///   %convertOptionalBlock.
static bool trySwitchEnumPeephole(ConvertEscapeToNoEscapeInst *Cvt) {
  auto *blockArg = dyn_cast<SILArgument>(Cvt->getOperand());
  if (!blockArg)
    return false;
  auto *PredBB = Cvt->getParent()->getSinglePredecessorBlock();
  if (!PredBB)
    return false;
  auto *ConvertSuccessorBlock = Cvt->getParent()->getSingleSuccessorBlock();
  if (!ConvertSuccessorBlock)
    return false;
  auto *SwitchEnum1 = dyn_cast<SwitchEnumInst>(PredBB->getTerminator());
  if (!SwitchEnum1)
    return false;
  auto *DiamondSucc = getOptionalDiamondSuccessor(SwitchEnum1);
  if (!DiamondSucc)
    return false;
  auto *SwitchEnum2 = dyn_cast<SwitchEnumInst>(DiamondSucc->getTerminator());
  if (!SwitchEnum2)
    return false;
  auto *DiamondSucc2 = getOptionalDiamondSuccessor(SwitchEnum2);
  if (!DiamondSucc2)
    return false;
  if (DiamondSucc2->getNumArguments() != 1)
    return false;

  // Look for the last and only destroy.
  SILInstruction *onlyDestroy = [&]() -> SILInstruction * {
    SILInstruction *lastDestroy = nullptr;
    for (auto *Use : DiamondSucc2->getArgument(0)->getUses()) {
      SILInstruction *Usr = Use->getUser();
      if (isa<ReleaseValueInst>(Usr) || isa<StrongReleaseInst>(Usr) ||
          isa<DestroyValueInst>(Usr)) {
        if (lastDestroy)
          return nullptr;
        lastDestroy = Usr;
      }
    }
    return lastDestroy;
  }();
  if (!onlyDestroy)
    return false;

  // Replace the convert_escape_to_noescape instruction.
  {
    SILBuilderWithScope B(Cvt);
    auto NewCvt = B.createConvertEscapeToNoEscape(
        Cvt->getLoc(), Cvt->getOperand(), Cvt->getType(), true);
    Cvt->replaceAllUsesWith(NewCvt);
    Cvt->eraseFromParent();
  }

  // Extend the lifetime.
  SILBuilderWithScope B(SwitchEnum1);
  auto loc = RegularLocation::getAutoGeneratedLocation();
  auto copy =
      B.createCopyValue(loc, SwitchEnum1->getOperand());
  B.setInsertionPoint(onlyDestroy);
  B.createDestroyValue(loc, copy);
  return true;
}

/// Look for a single destroy user and possibly unowned apply uses.
static SILInstruction *getOnlyDestroy(CopyBlockWithoutEscapingInst *CB) {
  SILInstruction *onlyDestroy = nullptr;

  for (auto *Use : getNonDebugUses(CB)) {
    SILInstruction *Inst = Use->getUser();

    // If this an apply use, only handle unowned parameters.
    if (auto Apply = FullApplySite::isa(Inst)) {
      SILArgumentConvention Conv = Apply.getArgumentConvention(*Use);
      if (Conv != SILArgumentConvention::Direct_Unowned)
        return nullptr;
      continue;
    }

    // We have already seen one destroy.
    if (onlyDestroy)
      return nullptr;

    if (isa<DestroyValueInst>(Inst) || isa<ReleaseValueInst>(Inst) ||
        isa<StrongReleaseInst>(Inst)) {
      onlyDestroy = Inst;
      continue;
    }

    // Some other instruction.
    return nullptr;
  }

  if (!onlyDestroy)
    return nullptr;

  // Now look at whether the dealloc_stack or the destroy postdominates and
  // return the post dominator.
  auto *BlockInit = dyn_cast<InitBlockStorageHeaderInst>(CB->getBlock());
  if (!BlockInit)
    return nullptr;

  auto *AS = dyn_cast<AllocStackInst>(BlockInit->getBlockStorage());
  if (!AS)
    return nullptr;
  auto *Dealloc = AS->getSingleDeallocStack();
  if (!Dealloc || Dealloc->getParent() != onlyDestroy->getParent())
    return nullptr;

  // Return the later instruction.
  for (auto It = SILBasicBlock::iterator(onlyDestroy),
            E = Dealloc->getParent()->end();
       It != E; ++It) {
    if (&*It == Dealloc)
      return Dealloc;
  }
  return onlyDestroy;
}

/// Lower a copy_block_without_escaping instruction.
///
///    This involves replacing:
///
///      %copy = copy_block_without_escaping %block withoutEscaping %closure
///
///      ...
///      destroy_value %copy
///
///    by (roughly) the instruction sequence:
///
///      %copy = copy_block %block
///
///      ...
///      destroy_value %copy
///      %e = is_escaping %closure
///      cond_fail %e
///      destroy_value %closure
static bool fixupCopyBlockWithoutEscaping(CopyBlockWithoutEscapingInst *CB,
                                          bool &modifiedCFG) {
  // Find the end of the lifetime of the copy_block_without_escaping
  // instruction.
  auto &Fn  = *CB->getFunction();

  // If we find a single destroy, this destroy is going to be a destroy that may
  // be in the same block as CB. It is important that we make sure that the
  // destroy is in a different block than CB or any terminating blocks to ensure
  // that we can use the SSAUpdater if needed.
  auto *SingleDestroy = getOnlyDestroy(CB);
  if (SingleDestroy && SingleDestroy->getParent() == CB->getParent()) {
    modifiedCFG = true;
    {
      SILBuilderWithScope B(SingleDestroy);
      splitBasicBlockAndBranch(B, SingleDestroy, nullptr, nullptr);
    }

    {
      SILBuilderWithScope B(SingleDestroy);
      auto *Term = SingleDestroy->getParent()->getTerminator();
      if (Term->isFunctionExiting()) {
        splitBasicBlockAndBranch(B, &*std::next(SingleDestroy->getIterator()),
                                 nullptr, nullptr);
      }
    }
  }

  auto SentinelClosure = CB->getClosure();
  auto Loc = CB->getLoc();

  // At this point, we transform our copy_block_without_escaping into a
  // copy_block. This has a few important implications:
  //
  // 1. copy_block_without_escaping takes the sentinel value at +1. We will need
  //    to balance that +1.
  // 2. The destroy_value associated with the copy_block_without_escaping will
  //    be on the copy_block value.
  SILBuilderWithScope B(CB);
  auto *NewCB = B.createCopyBlock(Loc, CB->getBlock());
  CB->replaceAllUsesWith(NewCB);
  CB->eraseFromParent();

  auto generatedLoc = RegularLocation::getAutoGeneratedLocation();

  // If CB is in the entry block, we know that our definition of SentinelClosure
  // must be as well. Thus we know that we do not need to worry about loops or
  // dominance issues and can just insert destroy_values for the sentinel at the
  // lifetime end points.
  if (NewCB->getParent() == NewCB->getFunction()->getEntryBlock()) {
    // Our single destroy must not be in the entry block since if so, we would
    // have inserted an edge to appease the SSA updater.
    if (SingleDestroy) {
      SILBuilderWithScope B(std::next(SingleDestroy->getIterator()));
      SILValue V = SentinelClosure;
      SILValue isEscaping = B.createIsEscapingClosure(
          Loc, V, IsEscapingClosureInst::ObjCEscaping);
      B.createCondFail(Loc, isEscaping);
      B.createDestroyValue(Loc, V);
      return true;
    }

    // If we couldn't find a specific destroy_value, lifetime extend to the end
    // of the function.
    SmallVector<SILBasicBlock *, 4> ExitingBlocks;
    Fn.findExitingBlocks(ExitingBlocks);
    for (auto *Block : ExitingBlocks) {
      SILBuilderWithScope B(Block->getTerminator());
      SILValue V = SentinelClosure;
      SILValue isEscaping = B.createIsEscapingClosure(
          Loc, V, IsEscapingClosureInst::ObjCEscaping);
      B.createCondFail(Loc, isEscaping);
      B.createDestroyValue(Loc, V);
    }

    return true;
  }

  // Otherwise, we need to be more careful since we can have loops and may not
  // transitively dominate all uses of the closure. So we:
  //
  // 1. Create an Optional<T>.none at the entry.
  // 2. Create a destroy_value(val), val = Optional<T>.some(sentinel) in the cvt
  // block.
  // 3. Create a destroy_value at all exits of the value.
  //
  // and then use the SSAUpdater to ensure that we handle loops correctly.
  auto OptionalEscapingClosureTy =
      SILType::getOptionalType(SentinelClosure->getType());

  SILSSAUpdater Updater(Fn.getModule());
  Updater.Initialize(OptionalEscapingClosureTy);

  // Create the Optional.none as the beginning available value.
  {
    SILBuilderWithScope B(Fn.getEntryBlock()->begin());
    Updater.AddAvailableValue(
        Fn.getEntryBlock(),
        B.createOptionalNone(generatedLoc, OptionalEscapingClosureTy));
  }

  // Then create the Optional.some(closure sentinel).
  //
  // NOTE: We return the appropriate insertion point to insert the destroy_value
  // before the value (to ensure we handle loops). We need to get all available
  // values first though.
  auto *InitialValue = [&]() -> EnumInst * {
    SILBuilderWithScope B(NewCB);
    // Create the closure sentinel (the copy_block_without_escaping closure
    // operand consumed at +1, so we don't need a copy) to it.
    auto *Result = B.createOptionalSome(generatedLoc, SentinelClosure,
                                        OptionalEscapingClosureTy);
    Updater.AddAvailableValue(Result->getParent(), Result);
    return Result;
  }();

  // If we had a single destroy, creating a .none after it and add that as a
  // value to the SSA updater.
  if (SingleDestroy) {
    SILBuilderWithScope B(std::next(SingleDestroy->getIterator()));
    auto *Result =
        B.createOptionalNone(generatedLoc, OptionalEscapingClosureTy);
    Updater.AddAvailableValue(Result->getParent(), Result);
  }

  // Now that we have all of our available values, insert a destroy_value before
  // the initial Optional.some value using the SSA updater to ensure that we
  // handle loops correctly.
  {
    SILBuilderWithScope B(InitialValue);
    B.createDestroyValue(generatedLoc, Updater.GetValueInMiddleOfBlock(
                                           InitialValue->getParent()));
  }

  // And insert an is_escaping_closure, cond_fail, destroy_value at each of the
  // lifetime end points. This ensures we do not expand our lifetime too much.
  if (SingleDestroy) {
    SILBuilderWithScope B(std::next(SingleDestroy->getIterator()));
    SILValue V = Updater.GetValueInMiddleOfBlock(SingleDestroy->getParent());
    SILValue isEscaping =
        B.createIsEscapingClosure(Loc, V, IsEscapingClosureInst::ObjCEscaping);
    B.createCondFail(Loc, isEscaping);
    B.createDestroyValue(Loc, V);
  }

  // Then to be careful with regards to loops, insert at each of the destroy
  // blocks destroy_value to ensure that we obey ownership invariants.
  {
    SmallVector<SILBasicBlock *, 4> ExitingBlocks;
    findReachableExitBlocks(NewCB, ExitingBlocks);

    for (auto *Exit : ExitingBlocks) {
      auto *Term = Exit->getTerminator();
      auto *SafeClosureDestructionPt =
          getDeinitSafeClosureDestructionPoint(Term);
      SILBuilderWithScope B(SafeClosureDestructionPt);
      B.createDestroyValue(generatedLoc, Updater.GetValueInMiddleOfBlock(Exit));
    }
  }

  return true;
}

static bool fixupClosureLifetimes(SILFunction &Fn, bool &checkStackNesting,
                                  bool &modifiedCFG) {
  bool Changed = false;

  // tryExtendLifetimeToLastUse uses a cache of recursive instruction use
  // queries.
  llvm::DenseMap<SILInstruction *, SILInstruction *> MemoizedQueries;

  for (auto &BB : Fn) {
    auto I = BB.begin();
    while (I != BB.end()) {
      SILInstruction *Inst = &*I;
      ++I;

      // Handle, copy_block_without_escaping instructions.
      if (auto *CB = dyn_cast<CopyBlockWithoutEscapingInst>(Inst)) {
        Changed |= fixupCopyBlockWithoutEscaping(CB, modifiedCFG);
        continue;
      }

      // Otherwise, look at convert_escape_to_noescape [not_guaranteed]
      // instructions.
      auto *Cvt = dyn_cast<ConvertEscapeToNoEscapeInst>(Inst);
      if (!Cvt || Cvt->isLifetimeGuaranteed())
        continue;

      // First try to peephole a known pattern.
      if (!DisableConvertEscapeToNoEscapeSwitchEnumPeephole &&
          trySwitchEnumPeephole(Cvt)) {
        Changed |= true;
        continue;
      }

      if (tryExtendLifetimeToLastUse(Cvt, MemoizedQueries, I)) {
        Changed |= true;
        checkStackNesting = true;
        continue;
      }

      // Otherwise, extend the lifetime of the operand to the end of the
      // function.
      extendLifetimeToEndOfFunction(Fn, Cvt);
      Changed |= true;
    }
  }
  return Changed;
}

/// Fix-up the lifetime of the escaping closure argument of
/// convert_escape_to_noescape [not_guaranteed] instructions.
///
/// convert_escape_to_noescape [not_guaranteed] assume that someone guarantees
/// the lifetime of the operand for the duration of the trivial closure result.
/// SILGen does not guarantee this for '[not_guaranteed]' instructions so we
/// ensure it here.
namespace {
class ClosureLifetimeFixup : public SILFunctionTransform {

  /// The entry point to the transformation.
  void run() override {
    // Don't rerun diagnostics on deserialized functions.
    if (getFunction()->wasDeserializedCanonical())
      return;

    // Fixup convert_escape_to_noescape [not_guaranteed] and
    // copy_block_without_escaping instructions.

    bool checkStackNesting = false;
    bool modifiedCFG = false;

    if (fixupClosureLifetimes(*getFunction(), checkStackNesting, modifiedCFG)) {
      if (checkStackNesting){
        StackNesting SN;
        modifiedCFG =
            SN.correctStackNesting(getFunction()) == StackNesting::Changes::CFG;
      }
      if (modifiedCFG)
        invalidateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);
      else
        invalidateAnalysis(SILAnalysis::InvalidationKind::CallsAndInstructions);
    }
    LLVM_DEBUG(getFunction()->verify());

  }

};
} // end anonymous namespace

SILTransform *swift::createClosureLifetimeFixup() {
  return new ClosureLifetimeFixup();
}
